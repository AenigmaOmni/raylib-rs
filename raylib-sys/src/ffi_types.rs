/* automatically generated by rust-bindgen */

pub const PI: f64 = 3.141592653589793;
pub const DEG2RAD: f64 = 0.017453292519943295;
pub const RAD2DEG: f64 = 57.29577951308232;
pub const FLAG_SHOW_LOGO: u32 = 1;
pub const FLAG_FULLSCREEN_MODE: u32 = 2;
pub const FLAG_WINDOW_RESIZABLE: u32 = 4;
pub const FLAG_WINDOW_UNDECORATED: u32 = 8;
pub const FLAG_WINDOW_TRANSPARENT: u32 = 16;
pub const FLAG_MSAA_4X_HINT: u32 = 32;
pub const FLAG_VSYNC_HINT: u32 = 64;
pub const KEY_SPACE: u32 = 32;
pub const KEY_ESCAPE: u32 = 256;
pub const KEY_ENTER: u32 = 257;
pub const KEY_TAB: u32 = 258;
pub const KEY_BACKSPACE: u32 = 259;
pub const KEY_INSERT: u32 = 260;
pub const KEY_DELETE: u32 = 261;
pub const KEY_RIGHT: u32 = 262;
pub const KEY_LEFT: u32 = 263;
pub const KEY_DOWN: u32 = 264;
pub const KEY_UP: u32 = 265;
pub const KEY_PAGE_UP: u32 = 266;
pub const KEY_PAGE_DOWN: u32 = 267;
pub const KEY_HOME: u32 = 268;
pub const KEY_END: u32 = 269;
pub const KEY_CAPS_LOCK: u32 = 280;
pub const KEY_SCROLL_LOCK: u32 = 281;
pub const KEY_NUM_LOCK: u32 = 282;
pub const KEY_PRINT_SCREEN: u32 = 283;
pub const KEY_PAUSE: u32 = 284;
pub const KEY_F1: u32 = 290;
pub const KEY_F2: u32 = 291;
pub const KEY_F3: u32 = 292;
pub const KEY_F4: u32 = 293;
pub const KEY_F5: u32 = 294;
pub const KEY_F6: u32 = 295;
pub const KEY_F7: u32 = 296;
pub const KEY_F8: u32 = 297;
pub const KEY_F9: u32 = 298;
pub const KEY_F10: u32 = 299;
pub const KEY_F11: u32 = 300;
pub const KEY_F12: u32 = 301;
pub const KEY_LEFT_SHIFT: u32 = 340;
pub const KEY_LEFT_CONTROL: u32 = 341;
pub const KEY_LEFT_ALT: u32 = 342;
pub const KEY_RIGHT_SHIFT: u32 = 344;
pub const KEY_RIGHT_CONTROL: u32 = 345;
pub const KEY_RIGHT_ALT: u32 = 346;
pub const KEY_GRAVE: u32 = 96;
pub const KEY_SLASH: u32 = 47;
pub const KEY_BACKSLASH: u32 = 92;
pub const KEY_ZERO: u32 = 48;
pub const KEY_ONE: u32 = 49;
pub const KEY_TWO: u32 = 50;
pub const KEY_THREE: u32 = 51;
pub const KEY_FOUR: u32 = 52;
pub const KEY_FIVE: u32 = 53;
pub const KEY_SIX: u32 = 54;
pub const KEY_SEVEN: u32 = 55;
pub const KEY_EIGHT: u32 = 56;
pub const KEY_NINE: u32 = 57;
pub const KEY_A: u32 = 65;
pub const KEY_B: u32 = 66;
pub const KEY_C: u32 = 67;
pub const KEY_D: u32 = 68;
pub const KEY_E: u32 = 69;
pub const KEY_F: u32 = 70;
pub const KEY_G: u32 = 71;
pub const KEY_H: u32 = 72;
pub const KEY_I: u32 = 73;
pub const KEY_J: u32 = 74;
pub const KEY_K: u32 = 75;
pub const KEY_L: u32 = 76;
pub const KEY_M: u32 = 77;
pub const KEY_N: u32 = 78;
pub const KEY_O: u32 = 79;
pub const KEY_P: u32 = 80;
pub const KEY_Q: u32 = 81;
pub const KEY_R: u32 = 82;
pub const KEY_S: u32 = 83;
pub const KEY_T: u32 = 84;
pub const KEY_U: u32 = 85;
pub const KEY_V: u32 = 86;
pub const KEY_W: u32 = 87;
pub const KEY_X: u32 = 88;
pub const KEY_Y: u32 = 89;
pub const KEY_Z: u32 = 90;
pub const KEY_BACK: u32 = 4;
pub const KEY_MENU: u32 = 82;
pub const KEY_VOLUME_UP: u32 = 24;
pub const KEY_VOLUME_DOWN: u32 = 25;
pub const MOUSE_LEFT_BUTTON: u32 = 0;
pub const MOUSE_RIGHT_BUTTON: u32 = 1;
pub const MOUSE_MIDDLE_BUTTON: u32 = 2;
pub const MAX_TOUCH_POINTS: u32 = 2;
pub const GAMEPAD_PLAYER1: u32 = 0;
pub const GAMEPAD_PLAYER2: u32 = 1;
pub const GAMEPAD_PLAYER3: u32 = 2;
pub const GAMEPAD_PLAYER4: u32 = 3;
pub const GAMEPAD_PS3_BUTTON_TRIANGLE: u32 = 0;
pub const GAMEPAD_PS3_BUTTON_CIRCLE: u32 = 1;
pub const GAMEPAD_PS3_BUTTON_CROSS: u32 = 2;
pub const GAMEPAD_PS3_BUTTON_SQUARE: u32 = 3;
pub const GAMEPAD_PS3_BUTTON_L1: u32 = 6;
pub const GAMEPAD_PS3_BUTTON_R1: u32 = 7;
pub const GAMEPAD_PS3_BUTTON_L2: u32 = 4;
pub const GAMEPAD_PS3_BUTTON_R2: u32 = 5;
pub const GAMEPAD_PS3_BUTTON_START: u32 = 8;
pub const GAMEPAD_PS3_BUTTON_SELECT: u32 = 9;
pub const GAMEPAD_PS3_BUTTON_UP: u32 = 24;
pub const GAMEPAD_PS3_BUTTON_RIGHT: u32 = 25;
pub const GAMEPAD_PS3_BUTTON_DOWN: u32 = 26;
pub const GAMEPAD_PS3_BUTTON_LEFT: u32 = 27;
pub const GAMEPAD_PS3_BUTTON_PS: u32 = 12;
pub const GAMEPAD_PS3_AXIS_LEFT_X: u32 = 0;
pub const GAMEPAD_PS3_AXIS_LEFT_Y: u32 = 1;
pub const GAMEPAD_PS3_AXIS_RIGHT_X: u32 = 2;
pub const GAMEPAD_PS3_AXIS_RIGHT_Y: u32 = 5;
pub const GAMEPAD_PS3_AXIS_L2: u32 = 3;
pub const GAMEPAD_PS3_AXIS_R2: u32 = 4;
pub const GAMEPAD_XBOX_BUTTON_A: u32 = 0;
pub const GAMEPAD_XBOX_BUTTON_B: u32 = 1;
pub const GAMEPAD_XBOX_BUTTON_X: u32 = 2;
pub const GAMEPAD_XBOX_BUTTON_Y: u32 = 3;
pub const GAMEPAD_XBOX_BUTTON_LB: u32 = 4;
pub const GAMEPAD_XBOX_BUTTON_RB: u32 = 5;
pub const GAMEPAD_XBOX_BUTTON_SELECT: u32 = 6;
pub const GAMEPAD_XBOX_BUTTON_START: u32 = 7;
pub const GAMEPAD_XBOX_BUTTON_UP: u32 = 10;
pub const GAMEPAD_XBOX_BUTTON_RIGHT: u32 = 11;
pub const GAMEPAD_XBOX_BUTTON_DOWN: u32 = 12;
pub const GAMEPAD_XBOX_BUTTON_LEFT: u32 = 13;
pub const GAMEPAD_XBOX_BUTTON_HOME: u32 = 8;
pub const GAMEPAD_ANDROID_DPAD_UP: u32 = 19;
pub const GAMEPAD_ANDROID_DPAD_DOWN: u32 = 20;
pub const GAMEPAD_ANDROID_DPAD_LEFT: u32 = 21;
pub const GAMEPAD_ANDROID_DPAD_RIGHT: u32 = 22;
pub const GAMEPAD_ANDROID_DPAD_CENTER: u32 = 23;
pub const GAMEPAD_ANDROID_BUTTON_A: u32 = 96;
pub const GAMEPAD_ANDROID_BUTTON_B: u32 = 97;
pub const GAMEPAD_ANDROID_BUTTON_C: u32 = 98;
pub const GAMEPAD_ANDROID_BUTTON_X: u32 = 99;
pub const GAMEPAD_ANDROID_BUTTON_Y: u32 = 100;
pub const GAMEPAD_ANDROID_BUTTON_Z: u32 = 101;
pub const GAMEPAD_ANDROID_BUTTON_L1: u32 = 102;
pub const GAMEPAD_ANDROID_BUTTON_R1: u32 = 103;
pub const GAMEPAD_ANDROID_BUTTON_L2: u32 = 104;
pub const GAMEPAD_ANDROID_BUTTON_R2: u32 = 105;
pub const GAMEPAD_XBOX_AXIS_LEFT_X: u32 = 0;
pub const GAMEPAD_XBOX_AXIS_LEFT_Y: u32 = 1;
pub const GAMEPAD_XBOX_AXIS_RIGHT_X: u32 = 2;
pub const GAMEPAD_XBOX_AXIS_RIGHT_Y: u32 = 3;
pub const GAMEPAD_XBOX_AXIS_LT: u32 = 4;
pub const GAMEPAD_XBOX_AXIS_RT: u32 = 5;
pub const MAX_SHADER_LOCATIONS: u32 = 32;
pub const MAX_MATERIAL_MAPS: u32 = 12;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vector2 {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_Vector2() {
    assert_eq!(
        ::std::mem::size_of::<Vector2>(),
        8usize,
        concat!("Size of: ", stringify!(Vector2))
    );
    assert_eq!(
        ::std::mem::align_of::<Vector2>(),
        4usize,
        concat!("Alignment of ", stringify!(Vector2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Vector2>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vector2),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Vector2>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Vector2),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vector3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_Vector3() {
    assert_eq!(
        ::std::mem::size_of::<Vector3>(),
        12usize,
        concat!("Size of: ", stringify!(Vector3))
    );
    assert_eq!(
        ::std::mem::align_of::<Vector3>(),
        4usize,
        concat!("Alignment of ", stringify!(Vector3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Vector3>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vector3),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Vector3>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Vector3),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Vector3>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vector3),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vector4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_Vector4() {
    assert_eq!(
        ::std::mem::size_of::<Vector4>(),
        16usize,
        concat!("Size of: ", stringify!(Vector4))
    );
    assert_eq!(
        ::std::mem::align_of::<Vector4>(),
        4usize,
        concat!("Alignment of ", stringify!(Vector4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Vector4>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vector4),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Vector4>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Vector4),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Vector4>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vector4),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Vector4>())).w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Vector4),
            "::",
            stringify!(w)
        )
    );
}
pub type Quaternion = Vector4;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Matrix {
    pub m0: f32,
    pub m4: f32,
    pub m8: f32,
    pub m12: f32,
    pub m1: f32,
    pub m5: f32,
    pub m9: f32,
    pub m13: f32,
    pub m2: f32,
    pub m6: f32,
    pub m10: f32,
    pub m14: f32,
    pub m3: f32,
    pub m7: f32,
    pub m11: f32,
    pub m15: f32,
}
#[test]
fn bindgen_test_layout_Matrix() {
    assert_eq!(
        ::std::mem::size_of::<Matrix>(),
        64usize,
        concat!("Size of: ", stringify!(Matrix))
    );
    assert_eq!(
        ::std::mem::align_of::<Matrix>(),
        4usize,
        concat!("Alignment of ", stringify!(Matrix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m4 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m8 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m12 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m12)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m5 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m9 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m9)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m13 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m13)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m2 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m6 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m10 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m10)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m14 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m14)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m3 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m7 as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m7)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m11 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m15 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m15)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Color {
    pub r: ::std::os::raw::c_uchar,
    pub g: ::std::os::raw::c_uchar,
    pub b: ::std::os::raw::c_uchar,
    pub a: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_Color() {
    assert_eq!(
        ::std::mem::size_of::<Color>(),
        4usize,
        concat!("Size of: ", stringify!(Color))
    );
    assert_eq!(
        ::std::mem::align_of::<Color>(),
        1usize,
        concat!("Alignment of ", stringify!(Color))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Color>())).r as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Color), "::", stringify!(r))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Color>())).g as *const _ as usize },
        1usize,
        concat!("Offset of field: ", stringify!(Color), "::", stringify!(g))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Color>())).b as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(Color), "::", stringify!(b))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Color>())).a as *const _ as usize },
        3usize,
        concat!("Offset of field: ", stringify!(Color), "::", stringify!(a))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Rectangle {
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
}
#[test]
fn bindgen_test_layout_Rectangle() {
    assert_eq!(
        ::std::mem::size_of::<Rectangle>(),
        16usize,
        concat!("Size of: ", stringify!(Rectangle))
    );
    assert_eq!(
        ::std::mem::align_of::<Rectangle>(),
        4usize,
        concat!("Alignment of ", stringify!(Rectangle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Rectangle>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rectangle),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Rectangle>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Rectangle),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Rectangle>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Rectangle),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Rectangle>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Rectangle),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Image {
    pub data: *mut ::std::os::raw::c_void,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub mipmaps: ::std::os::raw::c_int,
    pub format: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Image() {
    assert_eq!(
        ::std::mem::size_of::<Image>(),
        24usize,
        concat!("Size of: ", stringify!(Image))
    );
    assert_eq!(
        ::std::mem::align_of::<Image>(),
        8usize,
        concat!("Alignment of ", stringify!(Image))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Image>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Image),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Image>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Image),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Image>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Image),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Image>())).mipmaps as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Image),
            "::",
            stringify!(mipmaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Image>())).format as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Image),
            "::",
            stringify!(format)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Texture2D {
    pub id: ::std::os::raw::c_uint,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub mipmaps: ::std::os::raw::c_int,
    pub format: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Texture2D() {
    assert_eq!(
        ::std::mem::size_of::<Texture2D>(),
        20usize,
        concat!("Size of: ", stringify!(Texture2D))
    );
    assert_eq!(
        ::std::mem::align_of::<Texture2D>(),
        4usize,
        concat!("Alignment of ", stringify!(Texture2D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Texture2D>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Texture2D),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Texture2D>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Texture2D),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Texture2D>())).height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Texture2D),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Texture2D>())).mipmaps as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Texture2D),
            "::",
            stringify!(mipmaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Texture2D>())).format as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Texture2D),
            "::",
            stringify!(format)
        )
    );
}
pub type Texture = Texture2D;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RenderTexture2D {
    pub id: ::std::os::raw::c_uint,
    pub texture: Texture2D,
    pub depth: Texture2D,
}
#[test]
fn bindgen_test_layout_RenderTexture2D() {
    assert_eq!(
        ::std::mem::size_of::<RenderTexture2D>(),
        44usize,
        concat!("Size of: ", stringify!(RenderTexture2D))
    );
    assert_eq!(
        ::std::mem::align_of::<RenderTexture2D>(),
        4usize,
        concat!("Alignment of ", stringify!(RenderTexture2D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenderTexture2D>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RenderTexture2D),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenderTexture2D>())).texture as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RenderTexture2D),
            "::",
            stringify!(texture)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenderTexture2D>())).depth as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RenderTexture2D),
            "::",
            stringify!(depth)
        )
    );
}
pub type RenderTexture = RenderTexture2D;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CharInfo {
    pub value: ::std::os::raw::c_int,
    pub rec: Rectangle,
    pub offsetX: ::std::os::raw::c_int,
    pub offsetY: ::std::os::raw::c_int,
    pub advanceX: ::std::os::raw::c_int,
    pub data: *mut ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_CharInfo() {
    assert_eq!(
        ::std::mem::size_of::<CharInfo>(),
        40usize,
        concat!("Size of: ", stringify!(CharInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CharInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CharInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CharInfo>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CharInfo),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CharInfo>())).rec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CharInfo),
            "::",
            stringify!(rec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CharInfo>())).offsetX as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CharInfo),
            "::",
            stringify!(offsetX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CharInfo>())).offsetY as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CharInfo),
            "::",
            stringify!(offsetY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CharInfo>())).advanceX as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CharInfo),
            "::",
            stringify!(advanceX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CharInfo>())).data as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CharInfo),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Font {
    pub texture: Texture2D,
    pub baseSize: ::std::os::raw::c_int,
    pub charsCount: ::std::os::raw::c_int,
    pub chars: *mut CharInfo,
}
#[test]
fn bindgen_test_layout_Font() {
    assert_eq!(
        ::std::mem::size_of::<Font>(),
        40usize,
        concat!("Size of: ", stringify!(Font))
    );
    assert_eq!(
        ::std::mem::align_of::<Font>(),
        8usize,
        concat!("Alignment of ", stringify!(Font))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Font>())).texture as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Font),
            "::",
            stringify!(texture)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Font>())).baseSize as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Font),
            "::",
            stringify!(baseSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Font>())).charsCount as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Font),
            "::",
            stringify!(charsCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Font>())).chars as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Font),
            "::",
            stringify!(chars)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Camera3D {
    pub position: Vector3,
    pub target: Vector3,
    pub up: Vector3,
    pub fovy: f32,
    pub type_: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Camera3D() {
    assert_eq!(
        ::std::mem::size_of::<Camera3D>(),
        44usize,
        concat!("Size of: ", stringify!(Camera3D))
    );
    assert_eq!(
        ::std::mem::align_of::<Camera3D>(),
        4usize,
        concat!("Alignment of ", stringify!(Camera3D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Camera3D>())).position as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera3D),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Camera3D>())).target as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera3D),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Camera3D>())).up as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera3D),
            "::",
            stringify!(up)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Camera3D>())).fovy as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera3D),
            "::",
            stringify!(fovy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Camera3D>())).type_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera3D),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Camera2D {
    pub offset: Vector2,
    pub target: Vector2,
    pub rotation: f32,
    pub zoom: f32,
}
#[test]
fn bindgen_test_layout_Camera2D() {
    assert_eq!(
        ::std::mem::size_of::<Camera2D>(),
        24usize,
        concat!("Size of: ", stringify!(Camera2D))
    );
    assert_eq!(
        ::std::mem::align_of::<Camera2D>(),
        4usize,
        concat!("Alignment of ", stringify!(Camera2D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Camera2D>())).offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera2D),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Camera2D>())).target as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera2D),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Camera2D>())).rotation as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera2D),
            "::",
            stringify!(rotation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Camera2D>())).zoom as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera2D),
            "::",
            stringify!(zoom)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BoundingBox {
    pub min: Vector3,
    pub max: Vector3,
}
#[test]
fn bindgen_test_layout_BoundingBox() {
    assert_eq!(
        ::std::mem::size_of::<BoundingBox>(),
        24usize,
        concat!("Size of: ", stringify!(BoundingBox))
    );
    assert_eq!(
        ::std::mem::align_of::<BoundingBox>(),
        4usize,
        concat!("Alignment of ", stringify!(BoundingBox))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BoundingBox>())).min as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BoundingBox),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BoundingBox>())).max as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BoundingBox),
            "::",
            stringify!(max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Mesh {
    pub vertexCount: ::std::os::raw::c_int,
    pub triangleCount: ::std::os::raw::c_int,
    pub vertices: *mut f32,
    pub texcoords: *mut f32,
    pub texcoords2: *mut f32,
    pub normals: *mut f32,
    pub tangents: *mut f32,
    pub colors: *mut ::std::os::raw::c_uchar,
    pub indices: *mut ::std::os::raw::c_ushort,
    pub vaoId: ::std::os::raw::c_uint,
    pub vboId: [::std::os::raw::c_uint; 7usize],
}
#[test]
fn bindgen_test_layout_Mesh() {
    assert_eq!(
        ::std::mem::size_of::<Mesh>(),
        96usize,
        concat!("Size of: ", stringify!(Mesh))
    );
    assert_eq!(
        ::std::mem::align_of::<Mesh>(),
        8usize,
        concat!("Alignment of ", stringify!(Mesh))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).vertexCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(vertexCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).triangleCount as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(triangleCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).vertices as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(vertices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).texcoords as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(texcoords)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).texcoords2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(texcoords2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).normals as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(normals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).tangents as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(tangents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).colors as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).indices as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(indices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).vaoId as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(vaoId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).vboId as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(vboId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Shader {
    pub id: ::std::os::raw::c_uint,
    pub locs: [::std::os::raw::c_int; 32usize],
}
#[test]
fn bindgen_test_layout_Shader() {
    assert_eq!(
        ::std::mem::size_of::<Shader>(),
        132usize,
        concat!("Size of: ", stringify!(Shader))
    );
    assert_eq!(
        ::std::mem::align_of::<Shader>(),
        4usize,
        concat!("Alignment of ", stringify!(Shader))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Shader>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Shader),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Shader>())).locs as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Shader),
            "::",
            stringify!(locs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MaterialMap {
    pub texture: Texture2D,
    pub color: Color,
    pub value: f32,
}
#[test]
fn bindgen_test_layout_MaterialMap() {
    assert_eq!(
        ::std::mem::size_of::<MaterialMap>(),
        28usize,
        concat!("Size of: ", stringify!(MaterialMap))
    );
    assert_eq!(
        ::std::mem::align_of::<MaterialMap>(),
        4usize,
        concat!("Alignment of ", stringify!(MaterialMap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MaterialMap>())).texture as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MaterialMap),
            "::",
            stringify!(texture)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MaterialMap>())).color as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MaterialMap),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MaterialMap>())).value as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MaterialMap),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Material {
    pub shader: Shader,
    pub maps: [MaterialMap; 12usize],
    pub params: *mut f32,
}
#[test]
fn bindgen_test_layout_Material() {
    assert_eq!(
        ::std::mem::size_of::<Material>(),
        480usize,
        concat!("Size of: ", stringify!(Material))
    );
    assert_eq!(
        ::std::mem::align_of::<Material>(),
        8usize,
        concat!("Alignment of ", stringify!(Material))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Material>())).shader as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Material),
            "::",
            stringify!(shader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Material>())).maps as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(Material),
            "::",
            stringify!(maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Material>())).params as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(Material),
            "::",
            stringify!(params)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Model {
    pub mesh: Mesh,
    pub transform: Matrix,
    pub material: Material,
}
#[test]
fn bindgen_test_layout_Model() {
    assert_eq!(
        ::std::mem::size_of::<Model>(),
        640usize,
        concat!("Size of: ", stringify!(Model))
    );
    assert_eq!(
        ::std::mem::align_of::<Model>(),
        8usize,
        concat!("Alignment of ", stringify!(Model))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Model>())).mesh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Model),
            "::",
            stringify!(mesh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Model>())).transform as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Model),
            "::",
            stringify!(transform)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Model>())).material as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(Model),
            "::",
            stringify!(material)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Ray {
    pub position: Vector3,
    pub direction: Vector3,
}
#[test]
fn bindgen_test_layout_Ray() {
    assert_eq!(
        ::std::mem::size_of::<Ray>(),
        24usize,
        concat!("Size of: ", stringify!(Ray))
    );
    assert_eq!(
        ::std::mem::align_of::<Ray>(),
        4usize,
        concat!("Alignment of ", stringify!(Ray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Ray>())).position as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Ray),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Ray>())).direction as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Ray),
            "::",
            stringify!(direction)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RayHitInfo {
    pub hit: bool,
    pub distance: f32,
    pub position: Vector3,
    pub normal: Vector3,
}
#[test]
fn bindgen_test_layout_RayHitInfo() {
    assert_eq!(
        ::std::mem::size_of::<RayHitInfo>(),
        32usize,
        concat!("Size of: ", stringify!(RayHitInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<RayHitInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(RayHitInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RayHitInfo>())).hit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RayHitInfo),
            "::",
            stringify!(hit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RayHitInfo>())).distance as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RayHitInfo),
            "::",
            stringify!(distance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RayHitInfo>())).position as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RayHitInfo),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RayHitInfo>())).normal as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RayHitInfo),
            "::",
            stringify!(normal)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Wave {
    pub sampleCount: ::std::os::raw::c_uint,
    pub sampleRate: ::std::os::raw::c_uint,
    pub sampleSize: ::std::os::raw::c_uint,
    pub channels: ::std::os::raw::c_uint,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_Wave() {
    assert_eq!(
        ::std::mem::size_of::<Wave>(),
        24usize,
        concat!("Size of: ", stringify!(Wave))
    );
    assert_eq!(
        ::std::mem::align_of::<Wave>(),
        8usize,
        concat!("Alignment of ", stringify!(Wave))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Wave>())).sampleCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Wave),
            "::",
            stringify!(sampleCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Wave>())).sampleRate as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Wave),
            "::",
            stringify!(sampleRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Wave>())).sampleSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Wave),
            "::",
            stringify!(sampleSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Wave>())).channels as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Wave),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Wave>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Wave),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sound {
    pub audioBuffer: *mut ::std::os::raw::c_void,
    pub source: ::std::os::raw::c_uint,
    pub buffer: ::std::os::raw::c_uint,
    pub format: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Sound() {
    assert_eq!(
        ::std::mem::size_of::<Sound>(),
        24usize,
        concat!("Size of: ", stringify!(Sound))
    );
    assert_eq!(
        ::std::mem::align_of::<Sound>(),
        8usize,
        concat!("Alignment of ", stringify!(Sound))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sound>())).audioBuffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sound),
            "::",
            stringify!(audioBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sound>())).source as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Sound),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sound>())).buffer as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Sound),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sound>())).format as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Sound),
            "::",
            stringify!(format)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicData {
    _unused: [u8; 0],
}
pub type Music = *mut MusicData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AudioStream {
    pub sampleRate: ::std::os::raw::c_uint,
    pub sampleSize: ::std::os::raw::c_uint,
    pub channels: ::std::os::raw::c_uint,
    pub audioBuffer: *mut ::std::os::raw::c_void,
    pub format: ::std::os::raw::c_int,
    pub source: ::std::os::raw::c_uint,
    pub buffers: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout_AudioStream() {
    assert_eq!(
        ::std::mem::size_of::<AudioStream>(),
        40usize,
        concat!("Size of: ", stringify!(AudioStream))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioStream>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioStream))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioStream>())).sampleRate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStream),
            "::",
            stringify!(sampleRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioStream>())).sampleSize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStream),
            "::",
            stringify!(sampleSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioStream>())).channels as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStream),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioStream>())).audioBuffer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStream),
            "::",
            stringify!(audioBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioStream>())).format as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStream),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioStream>())).source as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStream),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioStream>())).buffers as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStream),
            "::",
            stringify!(buffers)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VrDeviceInfo {
    pub hResolution: ::std::os::raw::c_int,
    pub vResolution: ::std::os::raw::c_int,
    pub hScreenSize: f32,
    pub vScreenSize: f32,
    pub vScreenCenter: f32,
    pub eyeToScreenDistance: f32,
    pub lensSeparationDistance: f32,
    pub interpupillaryDistance: f32,
    pub lensDistortionValues: [f32; 4usize],
    pub chromaAbCorrection: [f32; 4usize],
}
#[test]
fn bindgen_test_layout_VrDeviceInfo() {
    assert_eq!(
        ::std::mem::size_of::<VrDeviceInfo>(),
        64usize,
        concat!("Size of: ", stringify!(VrDeviceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VrDeviceInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(VrDeviceInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VrDeviceInfo>())).hResolution as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VrDeviceInfo),
            "::",
            stringify!(hResolution)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VrDeviceInfo>())).vResolution as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VrDeviceInfo),
            "::",
            stringify!(vResolution)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VrDeviceInfo>())).hScreenSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VrDeviceInfo),
            "::",
            stringify!(hScreenSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VrDeviceInfo>())).vScreenSize as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VrDeviceInfo),
            "::",
            stringify!(vScreenSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VrDeviceInfo>())).vScreenCenter as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VrDeviceInfo),
            "::",
            stringify!(vScreenCenter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VrDeviceInfo>())).eyeToScreenDistance as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VrDeviceInfo),
            "::",
            stringify!(eyeToScreenDistance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VrDeviceInfo>())).lensSeparationDistance as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VrDeviceInfo),
            "::",
            stringify!(lensSeparationDistance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VrDeviceInfo>())).interpupillaryDistance as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VrDeviceInfo),
            "::",
            stringify!(interpupillaryDistance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VrDeviceInfo>())).lensDistortionValues as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VrDeviceInfo),
            "::",
            stringify!(lensDistortionValues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VrDeviceInfo>())).chromaAbCorrection as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VrDeviceInfo),
            "::",
            stringify!(chromaAbCorrection)
        )
    );
}
pub const LOG_INFO: LogType = 1;
pub const LOG_WARNING: LogType = 2;
pub const LOG_ERROR: LogType = 4;
pub const LOG_DEBUG: LogType = 8;
pub const LOG_OTHER: LogType = 16;
pub type LogType = u32;
pub const LOC_VERTEX_POSITION: ShaderLocationIndex = 0;
pub const LOC_VERTEX_TEXCOORD01: ShaderLocationIndex = 1;
pub const LOC_VERTEX_TEXCOORD02: ShaderLocationIndex = 2;
pub const LOC_VERTEX_NORMAL: ShaderLocationIndex = 3;
pub const LOC_VERTEX_TANGENT: ShaderLocationIndex = 4;
pub const LOC_VERTEX_COLOR: ShaderLocationIndex = 5;
pub const LOC_MATRIX_MVP: ShaderLocationIndex = 6;
pub const LOC_MATRIX_MODEL: ShaderLocationIndex = 7;
pub const LOC_MATRIX_VIEW: ShaderLocationIndex = 8;
pub const LOC_MATRIX_PROJECTION: ShaderLocationIndex = 9;
pub const LOC_VECTOR_VIEW: ShaderLocationIndex = 10;
pub const LOC_COLOR_DIFFUSE: ShaderLocationIndex = 11;
pub const LOC_COLOR_SPECULAR: ShaderLocationIndex = 12;
pub const LOC_COLOR_AMBIENT: ShaderLocationIndex = 13;
pub const LOC_MAP_ALBEDO: ShaderLocationIndex = 14;
pub const LOC_MAP_METALNESS: ShaderLocationIndex = 15;
pub const LOC_MAP_NORMAL: ShaderLocationIndex = 16;
pub const LOC_MAP_ROUGHNESS: ShaderLocationIndex = 17;
pub const LOC_MAP_OCCLUSION: ShaderLocationIndex = 18;
pub const LOC_MAP_EMISSION: ShaderLocationIndex = 19;
pub const LOC_MAP_HEIGHT: ShaderLocationIndex = 20;
pub const LOC_MAP_CUBEMAP: ShaderLocationIndex = 21;
pub const LOC_MAP_IRRADIANCE: ShaderLocationIndex = 22;
pub const LOC_MAP_PREFILTER: ShaderLocationIndex = 23;
pub const LOC_MAP_BRDF: ShaderLocationIndex = 24;
pub type ShaderLocationIndex = u32;
pub const MAP_ALBEDO: TexmapIndex = 0;
pub const MAP_METALNESS: TexmapIndex = 1;
pub const MAP_NORMAL: TexmapIndex = 2;
pub const MAP_ROUGHNESS: TexmapIndex = 3;
pub const MAP_OCCLUSION: TexmapIndex = 4;
pub const MAP_EMISSION: TexmapIndex = 5;
pub const MAP_HEIGHT: TexmapIndex = 6;
pub const MAP_CUBEMAP: TexmapIndex = 7;
pub const MAP_IRRADIANCE: TexmapIndex = 8;
pub const MAP_PREFILTER: TexmapIndex = 9;
pub const MAP_BRDF: TexmapIndex = 10;
pub type TexmapIndex = u32;
pub const UNCOMPRESSED_GRAYSCALE: PixelFormat = 1;
pub const UNCOMPRESSED_GRAY_ALPHA: PixelFormat = 2;
pub const UNCOMPRESSED_R5G6B5: PixelFormat = 3;
pub const UNCOMPRESSED_R8G8B8: PixelFormat = 4;
pub const UNCOMPRESSED_R5G5B5A1: PixelFormat = 5;
pub const UNCOMPRESSED_R4G4B4A4: PixelFormat = 6;
pub const UNCOMPRESSED_R8G8B8A8: PixelFormat = 7;
pub const UNCOMPRESSED_R32: PixelFormat = 8;
pub const UNCOMPRESSED_R32G32B32: PixelFormat = 9;
pub const UNCOMPRESSED_R32G32B32A32: PixelFormat = 10;
pub const COMPRESSED_DXT1_RGB: PixelFormat = 11;
pub const COMPRESSED_DXT1_RGBA: PixelFormat = 12;
pub const COMPRESSED_DXT3_RGBA: PixelFormat = 13;
pub const COMPRESSED_DXT5_RGBA: PixelFormat = 14;
pub const COMPRESSED_ETC1_RGB: PixelFormat = 15;
pub const COMPRESSED_ETC2_RGB: PixelFormat = 16;
pub const COMPRESSED_ETC2_EAC_RGBA: PixelFormat = 17;
pub const COMPRESSED_PVRT_RGB: PixelFormat = 18;
pub const COMPRESSED_PVRT_RGBA: PixelFormat = 19;
pub const COMPRESSED_ASTC_4x4_RGBA: PixelFormat = 20;
pub const COMPRESSED_ASTC_8x8_RGBA: PixelFormat = 21;
pub type PixelFormat = u32;
pub const FILTER_POINT: TextureFilterMode = 0;
pub const FILTER_BILINEAR: TextureFilterMode = 1;
pub const FILTER_TRILINEAR: TextureFilterMode = 2;
pub const FILTER_ANISOTROPIC_4X: TextureFilterMode = 3;
pub const FILTER_ANISOTROPIC_8X: TextureFilterMode = 4;
pub const FILTER_ANISOTROPIC_16X: TextureFilterMode = 5;
pub type TextureFilterMode = u32;
pub const WRAP_REPEAT: TextureWrapMode = 0;
pub const WRAP_CLAMP: TextureWrapMode = 1;
pub const WRAP_MIRROR: TextureWrapMode = 2;
pub type TextureWrapMode = u32;
pub const BLEND_ALPHA: BlendMode = 0;
pub const BLEND_ADDITIVE: BlendMode = 1;
pub const BLEND_MULTIPLIED: BlendMode = 2;
pub type BlendMode = u32;
pub const GESTURE_NONE: Gestures = 0;
pub const GESTURE_TAP: Gestures = 1;
pub const GESTURE_DOUBLETAP: Gestures = 2;
pub const GESTURE_HOLD: Gestures = 4;
pub const GESTURE_DRAG: Gestures = 8;
pub const GESTURE_SWIPE_RIGHT: Gestures = 16;
pub const GESTURE_SWIPE_LEFT: Gestures = 32;
pub const GESTURE_SWIPE_UP: Gestures = 64;
pub const GESTURE_SWIPE_DOWN: Gestures = 128;
pub const GESTURE_PINCH_IN: Gestures = 256;
pub const GESTURE_PINCH_OUT: Gestures = 512;
pub type Gestures = u32;
pub const CAMERA_CUSTOM: CameraMode = 0;
pub const CAMERA_FREE: CameraMode = 1;
pub const CAMERA_ORBITAL: CameraMode = 2;
pub const CAMERA_FIRST_PERSON: CameraMode = 3;
pub const CAMERA_THIRD_PERSON: CameraMode = 4;
pub type CameraMode = u32;
pub const CAMERA_PERSPECTIVE: CameraType = 0;
pub const CAMERA_ORTHOGRAPHIC: CameraType = 1;
pub type CameraType = u32;
pub const HMD_DEFAULT_DEVICE: VrDeviceType = 0;
pub const HMD_OCULUS_RIFT_DK2: VrDeviceType = 1;
pub const HMD_OCULUS_RIFT_CV1: VrDeviceType = 2;
pub const HMD_OCULUS_GO: VrDeviceType = 3;
pub const HMD_VALVE_HTC_VIVE: VrDeviceType = 4;
pub const HMD_SONY_PSVR: VrDeviceType = 5;
pub type VrDeviceType = u32;
